Nagłówki
W efekcie dodawania instrukcji #include do pliku źródłowego rekurencyjnie zostają
przeklejone wszystkie pliki nagłówkowe -> i tak się znajdują definicje

forward declaration -> działa wszędzie tam ,gdzie nie potrzebują rozmiaru danego obiektu
np. wskaźniki i referencje będą ok dla poniższego przykładu , ale również metody mogą
zwracać takie niezdefiniowane obiekty (nawet bez & * )

class A;

class B
{//...};

W pliku źródłowym należy zadeklarować również istnienie wykorzystywanych pól/metod.

ale takie coś nie zadziała

// A.hpp
    #pragma once

    #include "B.hpp"

    class B;

    class A {
        B b;
    };

// B.hpp
    #pragma once

    #include "A.hpp"

    class A;

    class B {
        A a;
    };

kompilator wie tylko ,że taki typ istnieje ,lecz w takiej sytuacji nie jest w stanie
wydedukować rozmiaru obiektu

agłówek załączany do innego nagłówka staje się jego zależnością, co z tym związane
jeśli załączam po kolei a->b->c ,to jeśli zmodyfikuję a ,to cały łańcuch zostaje
przekompilowany

UWAGA! W celu zmniejszenia czasu kompilacji staraj się umieszać pliki nagłówkowe w plikach
źródłowych

####################################################################################
każdy plik źródłowy musi być przekształcony do tzw. object file
te pliki są następnie linkowane do bibliotek i plików wykonywalnych

1.Preprocesor
Pierwsze ,co robi kompilator na plikach źródłwoych do odpala na nich Preprocesor.
Jedynie pliki źródłowe są przekazywane do kompilatora , pliki nagłówkowe nie są

pliki źródłowe są otwierane tylko jeden raz przez Preprocesor , pliki nagłówkowe
są wiele razy otwierane ,gdyż są załączane do plików źródłowych

Dla każdego pliku źródłowego Preprocesor tworzy jednostkę translacji poprzez wstawianie
zawartości(chyba pliku nagłówkowego) gdy znajdzie on dyrektywę #include
oraz będzie wywalać zawartość z bloków kompilacji warunkowej dla których będzie false
oraz ogarnia makra

Po zakończeniu preprocessingu wszystkie dyrektywy Preprocesora zostaja usunięte
oraz cały kod znajduje się w jednym pliku .cpp

UWAGA NA MAKRA  -> błędy związane z typowaniem nie są tutaj wykrywane

jeśli chcę tylko potraktować preprocesorem kilka plików .cpp i otrzymać wynikowy .cpp
to robię tak:

g++ -E main.cpp file.cpp   ale to zwróci mi tylko wynik na ekran
g++ -E main.cpp file.cpp > preprocessed.cpp zwróci mi wszystko do pliku

2.Diagonostyka
tzw. front-end
1-faza kompilatora -> sprawdzanie poprawności składniowej preprocessed.cpp

3.Optymalizacja
middle-end
generowanie drzew AST
flagi optymalizacyjne
-O0: optymalizacja czasu kompilacji (domyślna wartość)
-O1 lub -O: optymalizacja wielkości kodu oraz czasu wykonywania (poziom 1)
-O2: optymalizacja wielkości kodu oraz czasu wykonywania (poziom 2)
-O3: optymalizacja wielkości kodu oraz czasu wykonywania (poziom 3)
-Os: optymalizacja wielkości kodu
-Ofast: optymalizacja -O3 z dodatkowymi optymalizacjami obliczeniowymi

4.Generowanie kodu assemblera
by wygenerować kod assemblera z pliku .cpp wystarczy:
g++ -S main.cpp

5.Generowanie pliku obiektowego
przetworzenie kodu assemblera na kod maszynowy -> powstają pliki .o
g++ -o main.cpp

6.Linkowanie
Wszystkie pliki obiektowe są łączone w plik wynikowy -> sprawdzanie istnienia użytych
symboli , jeśli nie zostanie jakiś symbol odnaleziony -> błąd linkera (undefined refference
itd...)

Rodzaje plików wynikowych:
-plik wykonywalny
-plik obiektowy
-biblioteka statyczna
-biblioteka dynamiczna



Gdy Preprocesor skończy budować jednostkę translacji ,to zaczyna się etap kompilacji
oraz budowa object files


############
By uzyskać tę jednostkę translacji można użyć opcji -E przy g++ wraz z -o by nadać nazwę
g++ -E main.cpp -o main.ii
użycie g++ -c pozwala nam uzyskać object files
jednostka translacji będzie zawierać wszystkie pliki nagłówkowe potrzebne do uruchomienia
jej

####################################################################################

Statyczne biblioteki( archiwa ) .a lub .lib

Jest to paczka skompilowanych object files
Są częścią pliku wykonywalnego

Są dołączane podczas statycznego linkowania -> linker ekstrahuje kopie wymaganych
modułów obiektów z biblioteki do pliku wykonywalnego

Statyczne linkowanie musi być wykonywane ,gdy moduły są rekompilowane
Wszystkie moduły wymagane przez program są czasami statycznie linkowane i kopiowane
do pliku wykonywalnego -> statyczne budowanie

Konsekwencje statycznych bibliotek:
1.Jest tylko linkowana do aplikacji ,kod tej biblioteki jest osadzony w aplikacji
2.Każdy plik wykonywalny ma własną kopię biblioteki statycznej, więc jeśli produkt ma
kilka plików wykonywalnych ,to do każdego trzeba dodać tę bibliotekę ,co zwieksza rozmiary
produktu. Ale kopiowane są tylko te object files z biblioteki, które są rzeczywiście u
żywane przez plik wykonywalny
3.Odporność na konfilt nazw
4.Jednak by dokonać aktualizacji aplikacji wymagana jest zamiana całego pliku wykonywalnego

####################################################################################

Dynamiczne biblioteki ( shared libraries ) .so lub .dll

Wspołdzielone przez wiele plików wykonywalnych, object files są współdzielone
Moduły są ładowane do ramu ,zamiast linkowania ich do apki

Wymagają dynamicznego linkera
Na linuksie jest to ld.so
Wspierają zmienne środowiskowe ,by modyfikować swoje zachowanie

Konsekwencje ich używania:
1.One oraz nasze biblioteki , które od nich zależą muszą być dystryubowane z naszą apką
2.Wrażliwość na aktualizacje oraz na zgubienie ich
3.Jeśli więcej aplikacji korzysta z tych bibliotek ,to są bardziej efektywne pod kątem
miejsca na dysku.Jeśli jednak apka korzysta tylko z malutkiej części statycznej biblioteki
to będzie ona bardziej efektywna od dynamicznej
4.Mogą również mniej żreć pamięci ram ,gdyż są ładowane tam tylko raz
5.Jeśli nadejdzie aktualizacja ,to trzba podmienić tylko .dll bez ponownego rekompilowania
6.Pozwalają na ich ładowanie na żądanie ,co pozwala implementować pluginy

####################################################################################

Budowanie bibliotek statycznych
(jak chcesz samodzielnie zbudować system kompilacji ,to ogarnij shella )
1.
g++ -c **** tworzenie object file .o z każdego .cpp ( można dać kilka na raz)
np. g++ -c xd.c++
2.Używam polecenia ar np. ar r mylib.a file.o main.o -> otrzymuję biblioteke statyczną
3.Mogę teraz zbudować plik wykonywalny poprzez g++ -o main mylib.a -lm
-lm <- bez tego działa tak samo , nie wiem do czego służy
Uwaga! do polecenia ar trzeba dać artrybut r by nadać prawo do nadpisywania
budowanie statycznej biblioteki

####################################################################################

Budowanie bibliotek dynamicznych

W linuxach ld.so (dynamiczny linker/loader ) ładuje biblioteki dynamiczne wymagane przez
program oraz odpala program

Gdy odpalam program apka zwykle szuka tych bibliotek w /usr/local/lib ,jednak nie zawsze
tam one są. Musimy powiedzieć mu gdzie te biblioteki są.

Mając np. plik wykonywalny main mogę sprawdzić jakich bibliotek dynamicznych wymaga
ldd main

Biblioteki dynamiczne tworzy się z object files .o ale muszą być uprzednio skompilowane
z flagą -fPIC (position independ code)

By stworzyć bibliotekę dynamiczną należy zrobić tak:
g++ -shared -fPIC -o mylib.so file.o

Budowanie i linkowanie:
g++ -o main main.o ./mylib.so  <-- pokombinować z wieloma ścieżkami do bibliotek

####################################################################################

Co robi linker?
Po kompilacji fragmenty programu są klejone razem przez niego. Łączy dwa lub więcej
obiektów (relocatable objects) i dostarcza informacji potrzebnych
to umożliwiania odniesień między nimi. Relokacja (loader również ją robi) oraz
rozwiązanie odniesień zewnętrznych jest wykonywane przez niego

Co robi loader?
Ładuje wykonywalny obiekt (executable object)  do pamięci by go wykonywać

####################################################################################
Portowanie bibliotek do Windowsa <-- Tym się zajmę jak skończę projekt





















